"""
1. 개요
 1) Slicing 동작을 통해 영상의 일부 영역을 접근하여 처리하는 방법을 보인다.
 2) image2 = image를 행하면 img의 영상이 image2에 복사되는 것은 아니다.
    단지 2개의 영상 객체의 포인터가 같은 위치를 가리키게 된다.
    따라서 둘 중 하나의 영상을 바꾸면 다른 것도 바뀔 수도 있다.
    이것을 피하려면 새로운 변수에 원 영상을 복사하는 copy()를 사용하던가 직접 복사를 유발하는 동작을 시켜야 한다.
    복사하는 방법의 사례: image2 = image.copy()
    복사를 유발하는 동작: image2 = image.astype('uint8') 등..
    만약 image2가 이미 image와 같은 크기, 같은 데이터 형으로 선언되어 있다면: image2[:] = image[:]

2. 주요 함수
    ndarray.astype('uint8'): ndarray를 uint8형으로 만들어 반환한다.
    ndarray.astype(dtype=np.uint8): ndarray를 uint8형으로 만들어 반환한다.

3. 주의 사항
    python 3에서는 정수에 나누기를 행하면 부동소수 데이터가 만들어진다. 스칼라 값을 정수로 바꾸려면;
    1) int() 함수를 통해 변환한다. 예: int(3.95) => 3
    2) 몫을 구하는 // 연산자를 통해 정수 데이터를 얻을 수도 있다. 예: 487 //2 => 246

3. 미션
    소스 하단의 미션 과제와 도전 과제(2개)를 수행하시오.

"""

import cv2 as cv
import numpy as np              # 아직은 사용 안함.

# ========================================================================================================
# 단계 0:  영상이 존재하는 폴더와 파일 이름을 지정하기.
# ========================================================================================================
# 다음 사례를 활용하여 영상 파일이 있는 폴더를 적절히 지정하시오.
Path = 'd:\Work\StudyImages\Images\\'       # \\ 오류 발생 방지. \만 쓰면 오류.
#Path = 'd:/CV/Images/'       # \\ 오류 발생 방지. \만 쓰면 오류.
#Path = '../../Images/'               # 현재 상위 폴더의 상위 폴더 아래에 있는 Images 폴더.
Path = '../data/'
Name = 'lenna.bmp'
Name = 'monarch.bmp'
#Name = 'colorbar_chart2.jpg'
FullName = Path + Name

#"""
# ========================================================================================================
# 단계 1 : 영상 파일을 열어 화면에 출력하기
# ========================================================================================================
image = cv.imread(FullName)
assert image is not None, 'No image file....!'  # 입력 영상을 제대로 읽어오지 못하여 NULL을 반환.
cv.imshow('Step 1: Original', image)
cv.waitKey(0)
cv.destroyWindow('Step 1: Original')


# ========================================================================================================
# 단계 2 : 영상데이터의 정보를 출력한다.
# ========================================================================================================
print('\nStep 2: image.shape=', image.shape)
row, col = image.shape[:2]          # 0에서 1까지 원소를 assign한다.
ch = image.shape[-1]                # -1은 제일 마지막 원소를 의미한다.
#print('row={} col={} ch={}'.format(row, col, ch) )
# .format은 ()변수에 가장 적합한 문자열을 만들어 {}자리에 넣는다..
print(f'row={row} col={col} ch={ch}')

col, row = image.shape[1::-1]   # reverse indexing. shape[1]에서 끝(:)까지. step=-1
#print('garo={} sero={}'.format(col, row))  # 때로 가로x세로 순으로 정보가 필요할 때가 있다.
print(f'garo={col} sero={row}')
# 예: cv.resize(영상, (가로*세로)) 영상을 (가로*세로) 크기로 조절하고 싶을 때.


# ========================================================================================================
# 단계 3 : 영상의 일부를 역상으로 반전하여 출력한다.
# image가 매트릭스형 자료이므로 indexing 처리가 가능...
# ========================================================================================================

# 아래 1, 2, 3, 4의 방법 중에서 하나를 선택하여 결과를 분석하시오. => 2c 영상이 파일에서 읽어 들인 원영상이 나오는지 확인.
image2 = image                      #1. 복사하는 것이 아니다. 포인터가 서로 같아서 두 변수가 같은 영상 데이터를 공유한다.
#image2 = image.astype('uint8')     #2. 원래는 데이터형을 바꾸는 목적인데 같은 형으로 복사하여 새로 만든다.
#image2 = image.astype(dtype=np.uint8)  #3. 원래는 데이터형을 바꾸는 목적인데 같은 형으로 복사하여 새로 만든다.
#image2 = image.copy()           #4. 복사하여 새로 만든다.

# 영상 일부 영역에 대하여 반전 처리
# [row, col, ch] : ','로 dimension을 구분한다.
# 3차원 데이터인데 [row, col]만 지정하면 나머지 ch의 각 채널에 대해서도 같은 처리가 이루어진다.
# 즉, [row, col, :] 지정한 것과 같은 결과를 낳는다. 맨 뒤에 있는 :은 생략 가능하다.
# [:, col, ch]은 for all row 의 의미이다. 맨 위에 있으면 아예 생략가능한데 앞에 있을 때는 :로 그 의미를 대신한다.
# 각 디멘전에서 A:B:C 로 표기 가능하다. A부터 (B-1)까지 C 간격으로 slicing 한다.

# 영상의 우측 반을 역상으로 만든다.
#image2[:, int(col/2):]  = 255-image[:, int(col/2):]    # col/2는 부동소수가 됨에 유의
image2[:, col//2:] = 255 - image[:, col//2:]             # int(col/2) 대신 활용 가능. 몫 = //
cv.imshow('step 3a. right half inverted(3 channel)', image2)

# 영상의 좌측 반의 채널 1(green) 만을 보색으로 만들어 본다.
image2[:, 0:int(col/2), 1] = 255-image[:, 0:int(col/2), 1]       # col/2는 부동소수가 됨에 유의
cv.imshow('step 3b. right half inverted + left half inverted(G channel)', image2)

# image2를 수정하였는데 image도 같이 수정될 수도 있다.
cv.imshow('step 3c. original image', image)          # 질문: 원본이 손상된 이유를 설명하시오.
if image is image2:     # 두 객체가 같은 객체인지 확인한다.
    print("# 질문: step 3c 원본이 손상된 이유를 설명하시오.")

cv.waitKey(0)
cv.destroyAllWindows()


# ========================================================================================================
# 단계 4 : 원영상 하부를 밝게 표현하여 본다.
# ========================================================================================================
image = cv.imread(FullName)
#image3 = image.astype('float64')/255        # image/255 처럼 단순하게 표현해도 된다.
image3 = image/255        # 복사를 유도하는 동작을 수행하였다. 두 변수는 개별 객체로 작동한다.
image3[int(row/2):, :] = 1.5 * image3[int(row/2):, :]     # row/2는 부동소수가 됨에 유의
cv.imshow('step 4a. lower half brightened', image3)
cv.imshow('step 4b. original image', image)          # image와 image2가 모두 같은 영상 어레이를 가리킨다.
print("step 4: 주의!!! 지금 부동소수 데이터를 보고 있습니다.")
cv.waitKey(0)


cv.destroyAllWindows()     # This does not work in 2.7. Fine in 3.6
exit(0)
#"""

"""




# ========================================================================================================
# 자율 학습 과제 - 연습용..
# 영상의 10번째 줄부터 20번째 줄까지 가로 한 줄을 특정 색상(붉은 색)으로 바꾸시오.
# ? 부분을 적절한 표현으로 작성하면 됩니다...
# ========================================================================================================
img = cv.imread(FullName)
assert img is not None, 'No image file....!'  # 입력 영상을 제대로 읽어오지 못하여 NULL을 반환.
cv.imshow('Original', )                 # 읽어들인 영상 출력하기

col=img.shape[?]        # col=Number of column
RandomColor = [0, 0, 255]       # RandomColor를 붉은 색으로 지정    
img[?:?, 0:col] = RandomColor  # 특정 위치를 지정하여 가로 한 줄을 RandomColor로 대치
cv.imshow('Answer', img)        # 처리한 결과 보이기
cv.waitKey(0)
exit(0)
"""


# ========================================================================================================
# 미션 (1)
# 본 영상의 중심부만을 칼라로 표시하고 나머지 부분은 흑백으로 표시하시오.
#   - 예를 들어 3x3 영역으로 나누어 중심부 1개 영역만 칼라, 나머지 8개 영역은 흑백으로 표시합니다.
# 힌트: cvtColor
#   color conversion code : https://docs.opencv.org/3.4.3/d7/d1b/group__imgproc__misc.html#ga4e0972be5de079fed4e3a10e24ef5ef0
#   imgM = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
# 주의: 3채널로 흑백영상을 표현하는 방법 => BGR 3개 채널을 같은 값으로 채워 넣는다.
# ========================================================================================================


# ========================================================================================================
# 미션 (2)
# monarch.bmp 영상의 좌측 상단을 제공된 흑백영상 2개를 좌측 상단, 우측 하단에 넣어 영상을 만들어 화면에 보이고, JPG로 저장하시오.
# 좌측 상단: char_90_A_256.bmp(0~255로 이루어진 영상), 우측 하단: char_A_bin.bmp(이진 영상 0, 255로 변환해야 할 것임)
# 출력 방법 - matplotlib, non-interactive mode로 먼저 보이고, 같은 내용을 openCV로 또 한번 더 보인다.
# 1. 일단 3개의 입력 영상을 각각 출력한다.
# 2. 좌측 상단, 우측 하단에 삽입한 monarch 영상을 보인다.
# 3. 위의 내용을 opencv로 한번 더 출력한다.
# ========================================================================================================





# ========================================================================================================
# 미션 - 검토 중..: ../data/smooth.png와 화소 값이 100% 같은 영상 데이터를 프로그램으로 생성하여 "test.png"로 저장하시오.
# test.png를 읽어들인 영상 어레이가 smooth.png의 영상 어레이의 데이터와 모두 같음을 보이면 됩니다.
# 제공된 영상은 세로선 2개가 0~255씩 증가하는 2차원 배열 데이터를 프로그램으로 생성하여 PNG 파일로 만든 것입니다.
#
# ========================================================================================================


"""
# ========================================================================================================
# 슬라이싱 사전 연습 - 숙지한 사람은 생략하시오...
# 슬라이싱의 기초: (연습) 리스트, 스트링 자료형에 대한 slicing 액세스 기법을 익힌다.
# ========================================================================================================
string = "1234567890ABCDEFG"         # slicing 표현법 start:stop[:step]
print (string[1:5])                 # 1에서 4까지 1씩 증가시키면서
# 2345

print (string[2:])                  # 3에서 끝까지 1씩 증가시키면서
# 34567890ABCDEFG

print (string[1:5:2])               # 1에서 4까지 2씩 증가시키면서
# 24

print (string[0::2])                # 0에서 끝까지 2씩 증가시키면서
# 13579ACEG

print(string[-1])
# G

print(string[-1:])
# G

print(string[-2:])
# FG

print(string[-3:])
# EFG

print(string[-len(string):])
# 1234567890ABCDEFG

print(string[-1:0:-1])
# GFEDCBA098765432

print(string[-1::-1])
# GFEDCBA0987654321

print(string[::-1])
# GFEDCBA0987654321

print(string[:-1])
# 1234567890ABCDEF

print(string[-1::])
# G

a = np.arange(4 * 8)
b = a.reshape(4, 8)
print("b=\n", b)
print("b[:, 4:]=\n", b[:, 4:])         # row: for all row,         col: from 4 to the end
print("b[2:, :]=\n", b[2:, :])         # row: from 2 to the end.   col : row: for all row
print("b[2:, ]=\n", b[2:, ])         # row: from 2 to the end.   col : row: for all row

exit(0)
"""
