/*
1. 변수종류
   정수형 : short(2), int(4), long(4), long long(8)
   실수형 : float(4), double(8), long double(8)
   문자형 : char(1)

2.형식 지정자
  %d : 정수를 10진수로 입력한다.
  %f : float형의 실수를 입력한다.
  %lf : double형의 실수를 입력한다.
  %c : 문자 형태로 입력한다.
  %s : 문자열 형태로 입력한다.

3. 1바이트 = 8비트

4. x += y
   x -= y
   x *= y
   x /= y
   x %= y
   x &=y
   x |=y
   x ^=y
   x >>= Y
   x <<= y
   x == y, x != y, x > y, x < y, x >= y, x <= y

5. 조건연산자
   a = (x > y) ? x : y;

6. switch문

   switch(op)
   {
	   case '+':
		  result = x + y;
		  break;
   }

7. while문

   int i = 0;

   while(i < 5)
   {
	   printf("a");
	   i++;
	}

8. do while문

   do
   {
	  ...
	}while(조건);  //조건이 참이면 반복을 계속한다.

9. [a, b]구간의 난수 : a + (rand()%(b-a+1));

10. 지역변수 : 함수또는 블록안에서 정의되는 변수. 지역변수는 해당블록이나 함수에서만 사용가능.
    전역변수 : 함수의 외부에서 선언되는 변수. 전역변수는 소스파일의 어느 곳에서든 사용가능.

	*블록이 다르면 같은 이름의 변수가 있어도 가능.
	*지역변수의 생존기간은 선언된 블록이 끝나면 자동으로 소멸된다.
	*지역변수를 초기화하지 않으면 쓰레기값이 저장되지만, 전역변수를 초기화되지 않으면 0이 저장된다.
	*같은 이름의 전역변수와 지역변수가 선언된다면, 지역변수가 우선시된다.

11. 생존시간
    정적할당 : 프로그램이 실행되는 동안에는 계속하여서 변수에 저장 공간이 할당된다.
	자동할당 : 블록이 시작되면서 변수가 할당되고 블록이 종료되면 저장공간이 회수된다.

	1)자동변수 - auto지정자
	  원칙적으로 auto를 붙여야 한다. ex) auto int a = 0;
	  하지만 함수나 블록 안에 선언된 변수에는 auto가 생략되어도 모두 자동 변수로 취급된다.
	2)정적변수 - static지정자
	  블록을 벗어나도 자동으로 제거되지 않는 변수다. 
	  정적변수는 지역변수와 전역변수 모두에 붙일 수 있다.
    3)레지스터변수 - register지정자
	  변수를 메모리에 저장하는 것이 아니라 레지스터(CPU)에 저장한다.
	  그래서 데이터를 읽고 쓰는 속도가 아주 빠르다.
	  레지스터변수는 지역변수만 사용가능하다.

12. 연결
    무연결 : 지역변수
	외부연결 : 전역변수로서 여러개의 소스파일에 걸쳐서 사용
	내부연결 : 전역변수로서 하나의 소스파일에서만 사용이가능

13. 배열
    배열은 같은종류의 대량의 데이터를 효율적으로 사용가능
	배열은 동일한 타입의 데이터가 여러개 저장되어있는 데이터 저장 장소이다.
	배열을 구성하는 각각의 항목을 배열요소 또는 배열원소라고 한다.
	배열 요소에는 번호가 붙어 있는데 이것을 인덱스 또는 첨자라고 부른다.
	배열은 메모리의 연속적인 공간에 저장된다.
	배열은 일반변수들과 함께 선언될 수 있다. 또 여러개의 배열을 하나의 라인에서 같이 선언할 수 있다.
	배열을 함수로 전달할 때 보통의 경우 값에의한 호출이 일어나지만, 배열의 경우에는 단순한 값에의한호출이 아니다.
	배열이 인수인 경우에는 배열의 원본이 매개 변수를 통하여 전달된다. 즉 배열의 경우에는 원본이 전달된다.
	배열은 매개 변수를 통해 원본을 참조하는 것이기 때문에 함수안에서 매개변수를 통하여 배열요소를 변경하면 원본배열을 변경시킨다.
	배열이 함수의 매개변수로 전달될때 배열요소의 값을 변경불가능하게 만드는 방법은 void print_array(const int a[], int size)를 하는 것이다.
    2차원배열에서 행의개수를 지정하지 않을 수 있다. ex) int s[][5];
	2차원배열 초기화 시 안쪽의 중괄호를 생략할 수 있다. 컴파일러가 행의크기에 따라서 초기값을 자동으로 분류한다.
	배열이 전역변수로 선언된 경우 초기화를 않하면 0으로 초기화하고 지역변수의 경우에는 쓰레기값이 저장된다.
	배열을 함수로 연결할 때 1차원배열은 배열의크기를 지정하지 않아도된고, 2차원배열에는 행의 크기를 생략가능. ex)int sum(int a[]), int sum(int[][3])

14. 포인터
    포인터는 메모리의 주소를 가지고 있는변수이다.
	포인터는 변수의 주소를 가지고 있는변수이다.
	주소연산자 & : 주소 연산자는 변수의 이름을 받아서 변수의 주소를 반환한다. ex) printf("i의 주소: %u", &i);
	포인터 선언 int *p;  :  정수를 가리키는 포인터p, 정수를 가리키는 변수의 주소를 가진 변수
	간접참조연산자* : *p는 p가 가리키는 위치에 있는 데이터를 가져오라는 의미.
	&연산자 : 변수의 주소를 구하여 포인터에 대입할 때 사용되는 연산자.
	*연산자 : 포인터를 통하여 변수를 간접 참조할 때 사용하는 연산자.
	포인터 사용 시 초기화하지 않고 사용하면 위험하다.
	포인터가 아무것도 가리키고 있지 않을 때는 NULL로 설정. NULL은 헤더파일 stdio.h에 0으로 정의되있음. ex) int *p = NULL;
	포인터 타입과 변수의 타입은 일치해야 한다.

15. 포인터 연산
    1 v = *p++    : p가 가리키는 값을 v에 대입한 후에 p를 증가한다.
	2 v = (*p)++  : p가 가리키는 값을 v에 대입한 후에 p가 가리키는 값을 증가한다.
	3 v = *++p    : p를 증가시킨 후에 p가 가리키는 값을 v에 대입한다.
	4 v = ++*p    : p가 가리키는 값을 가져온 후에 그 값을 증가하여 v에 대입한다.

16. 포인터의 형변환
    double *pd = &f;
	int *pi;

	pi = (int *)pd;

17. 함수 호출
    1 값에 의한 호출 : 복사본 전달
	2 참조에 의한 호출 : 원본 전달

18. 포인터 장점
    이진 트리, 연결리스트, 참조에의한호출, 동적메모리 할당
*/